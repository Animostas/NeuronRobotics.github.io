<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Bowler Spec</title>
        <meta name="viewport" content="width=device-width">

        <!-- Custom CSS-->
        <link rel="stylesheet" href="/css/main.css">
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">

	<!-- Optional theme -->
	<link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">
	<!-- SmartMenus jQuery Bootstrap Addon CSS -->
	<link href="/css/jquery.smartmenus.bootstrap.css" rel="stylesheet">
	<!-- Custom CSS -->
        <link rel="stylesheet" href="/css/Bootstraptweek.css">
 
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body  data-spy="scroll" data-target=".nav-example">
	<div class="container">
		<img src="/bowler.gif" alt ="No Image" style="height:100px;"/>
		<nav class="navbar navbar-inverse" role="navigation">
		  <div class="container-fluid" >
		    <!-- Collect the nav links, forms, and other content for toggling -->
		    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
		      <ul class="nav navbar-nav">
			<li><a href="/">Home</a></li>
			<li><a href="/Getting_Started/">Getting Started</a></li>
			<li><a href="/Protocol/">Protocol</a></li>
			<li><a href="/Examples/">Examples</a></li>
			<li class="dropdown">
			<a href="/Hardware/">Hardware</a>
			  <ul class="dropdown-menu">
			    <li><a href="/Hardware/Ready/">Ready</a></li>
			    <li><a href="/Hardware/In_Progress/">In Progress</a></li>
			    
			    <li class="divider"></li>
			  </ul>
			</li>
			<li class="dropdown">
			<a href="/SDK/">SDK </a>
			  <ul class="dropdown-menu">
			    <li><a href="/SDK/C_Bowler/">C Bowler</a></li>
				<li><a href="/SDK/C_Sharp/">C#</a></li>
				<li><a href="/SDK/node_JS/">node.JS</a></li>
				<li><a href="/SDK/NR_Console/">NR Console</a></li>
				<li><a href="/SDK/NR_dev_tools/">NR Dev Tools</a></li>
				<li><a href="/SDK/Python/">Python</a></li>
				<li><a href="/SDK/Ruby/">Ruby</a></li>
				<li><a href="/SDK/Java/">Java</a></li>
			  </ul>
			</li>
		
		      </ul>
		<ul class="nav navbar-nav navbar-right">
			<li><a href="https://github.com/NeuronRobotics" target="_blank">GitHub</a></li>
		</ul>
		    </div><!-- /.navbar-collapse -->
		  </div><!-- /.container-fluid -->
		</nav>
	<div>
	<div id= "sidebar" class="col-sm-3 col-md-2 sidebar">
	<div class="nav-example">
          <ul id="sidebarlist"class="nav nav-tabs nav-stacked nav-list">
          </ul>
	</div>
        </div>
		<div id="content" class="content">
         
        		<h1>Ruby DyIO API</h1>

<h2>Introduction</h2>

<p>This library facilitates communication with the [Neuron Robotics] DyIO open source coprocessor (see "http://bowler.io":http://bowler.io).  It is the official Ruby implementation of the
PC side of the Bowler API.</p>

<h2>Requirements</h2>

<p>This library requires EventMachine, EM::Synchrony, SerialPort, and DBus (see [insert urls here], dbus only required for linux Bluetooth).  Additionally, this library requires Ruby Fiber support
(Ruby 1.9+)</p>

<h2>Getting Started</h2>

<p>To start off, first initialize a new DyIO object:</p>

<p>```ruby
require 'dyio'</p>

<p>include Bowler</p>

<p>dyio = DyIO.new('/dev/DyIO0') # Assuming you're on linux, with the DyIO udev files installed
```</p>

<p>The Ruby DyIO libary uses the EventMachine library to provide an event-oriented approach to communicating with the DyIO.  Start the EventMachine reactor as follows:</p>

<p><code>ruby
dyio.connect do
  # your code here
end
</code></p>

<p>Then, you can set up devices and register callbacks, as such:</p>

<p>```ruby
dyio.connect do
  pot = dyio.get<em>channel</em>as<em>potentiometer 9
  servo = dyio.get</em>channel<em>as</em>servo 10</p>

<p>pot.on<em>every</em>chane do |fraction|
    puts 'Pot is #{fraction}'
    servo.move<em>to (200*fraction+20).to</em>i, 500 # move the servo to position 200*fraction+20 (20-220) over the course of 500 ms
  end
end
```</p>

<p>However, often times nested callbacks can be hard to manage. Consider the following example:</p>

<p>```ruby
dyio.connect do
  pot = dyio.get<em>channel</em>as<em>potentiometer 9
  servo = dyio.get</em>channel<em>as</em>servo 10
  button = dyio.get<em>channel</em>as_button 11</p>

<p>button.on<em>every</em>change do |pushed|
    if pushed
      pot.on<em>next</em>change do |frac|
        servo.move<em>to (200*frac+20), 500
      end
      dyio.command</em>to.get<em>channel</em>values
    end
  end
end
```</p>

<p>Because of this, all of the methods in the Ruby DyIO library support the EM::Synchrony pattern, which uses Fibers to allow for pseudo-sequential code writing:</p>

<p>```ruby
dyio.connect do
  pot = dyio.get<em>channel</em>as<em>potentiometer 9
  servo = dyio.get</em>channel<em>as</em>servo 10
  button = dyio.get<em>channel</em>as_button 11</p>

<p>button.on<em>every</em>change do |pushed|
    if pushed
      val = pot.fraction
      servo.move_to (200*val+20), 500
    end
  end
end
```</p>

<p>Mixing these two style generally produces the most readable code.</p>

<h2>Advanced Topics</h2>

<h3>EventMachine Primatives</h3>

<p>All EventMachine primatives are supported.  Note, however, that in order to function properly with the EM::Synchrony functionality used inside the Ruby DyIO library, you should use the EM::Synchrony versions, and not the normal EventMachine versions.  In the event that you have an existing vanilla EventMachine method that you would like to reuse, simply wrap it with a call to EM::Synchrony#sync</p>

<h3>Custom Peripherals</h3>

<p>Any single-channel custom peripheral should inherit from the <code>Bowler::IO::Channel</code> class at minimum.  If your device provides input, you should inherit from the <code>Bowler::IO::Input</code> class instead.  Additionally, devices are expected to call the #mode= method in their constructor, so as to configure the DyIO properly before use.  The (private) method #process_data may be overridden to provide event handlers with properly formatted data.  For instance, the Bowler::IO::Peripherals::Button class defines it as such:</p>

<p><code>ruby
def process_data(data)
  val = data[:channels][@channel_number].to_i(false)
  @cached_val = if @active_high then (val != 0) else (val == 0) end
  @cached_val
end
</code></p>

<p>Arrays can be returned to pass multiple values to the event handlers (the arrays are "expanded" using <code>*arr</code> when passed to the event handler blocks).  Finally, the #get<em>channel</em>as methods are implemented by searching the Bowler::IO::Peripherals module, so any custom peripherals may be placed there for ease of use.</p>

<h3>Custom Commands</h3>

<p>Command handling is done in the Bowler::CommandHandler class.  There are two types of relevant methods to implement here: commands and parsers.</p>

<h4>Commands</h4>

<p>Now, by default unspecified commands will have their names parsed and acted on automatically (see the documentation for Bowler::CommandHandler#method<em>missing).  However, to simplify name conversion, etc, you may define your own command methods in Bowler::CommandHandler (or a subclass of it, which you can then specify as the DyIO's command</em>handler, or as a module, which you can then <code>include</code> in Bowler::CommandHandler).  For example, set<em>channel</em>value is implemented as such:</p>

<p><code>ruby
def set_channel_value(num, val, opts_hsh)
    res = nil
    val_bytes = unless (val.is_a? Array)
                val.to_a(opts_hsh[:val_size])
              else
                val
              end
    unless opts_hsh[:time].nil?
      time_bytes = opts_hsh[:time].to_a(opts_hsh[:time_size])
      self.send_command('schv', :post, num, val_bytes, time_bytes)
    else
      self.send_command('schv', :post, num, val_bytes)
    end
end
</code></p>

<h4>Parsers</h4>

<p>The Bowler::CommandHandler class is also responsible for parsing incoming packets.  Such methods
start with parse, and are called automatically based on the command name to readable name lookup hash Bowler::EVENT<em>LOOKUP</em>NAMES, or just used directly if no such entry can be found.  Such a method should take in a single paramter (the results of the #parse<em>command method), and return a hash with at least a key <code>:raw_res</code> whose value is the passed in parameter.  The following is the parse</em>channel_mode method:</p>

<p><code>ruby
def parse_channel_mode(res)
  {:raw_res =&gt; res, :mode =&gt; CHAN_MODE_NAMES[res[:data][1]], :channel =&gt; res[:data][0]}
end
</code></p>





		</div>
	<div>
		  <div class="footer">
		    <div class="contact" style="float:right">
		      <p>
			<a href="https://NeuronRobotics.com">Neuron Robotics<a><br />
			Phone: +1 (877)474-6038<br/>
			E-mail: Info@NeuronRobotics.com<br/>
			95 Prescott St. Worcester, MA 01609<br/>
		      </p>
		    </div>
		  </div>
	  

	    <!-- Bootstrap core JavaScript
	    ================================================== -->
	    <!-- Placed at the end of the document so the pages load faster -->
	    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<!-- Latest compiled and minified JavaScript -->
	<script src="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
	<!-- SmartMenus jQuery plugin -->
<script type="text/javascript" src="/jquery.smartmenus.min.js"></script>

<!-- SmartMenus jQuery Bootstrap Addon -->
<script type="text/javascript" src="/jquery.smartmenus.bootstrap.min.js"></script>
<!-- Personal Sidebar jQuery Addon -->
<script type="text/javascript" src="/sidebar.js"></script>
	</div>
    </body>
</html>

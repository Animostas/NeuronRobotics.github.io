---
layout: info
title: "Bowler Spec"
date: 2014-03-17 18:24:20 
categories: jekyll update 
---

<h1>Ruby DyIO API</h1>

<h2>Introduction</h2>

<p>This library facilitates communication with the [Neuron Robotics] DyIO open source coprocessor (see "http://bowler.io":http://bowler.io).  It is the official Ruby implementation of the
PC side of the Bowler API.</p>

<h2>Requirements</h2>

<p>This library requires EventMachine, EM::Synchrony, SerialPort, and DBus (see [insert urls here], dbus only required for linux Bluetooth).  Additionally, this library requires Ruby Fiber support
(Ruby 1.9+)</p>

<h2>Getting Started</h2>

<p>To start off, first initialize a new DyIO object:</p>

<p>```ruby
require 'dyio'</p>

<p>include Bowler</p>

<p>dyio = DyIO.new('/dev/DyIO0') # Assuming you're on linux, with the DyIO udev files installed
```</p>

<p>The Ruby DyIO libary uses the EventMachine library to provide an event-oriented approach to communicating with the DyIO.  Start the EventMachine reactor as follows:</p>

<p><code>ruby
dyio.connect do
  # your code here
end
</code></p>

<p>Then, you can set up devices and register callbacks, as such:</p>

<p>```ruby
dyio.connect do
  pot = dyio.get<em>channel</em>as<em>potentiometer 9
  servo = dyio.get</em>channel<em>as</em>servo 10</p>

<p>pot.on<em>every</em>chane do |fraction|
    puts 'Pot is #{fraction}'
    servo.move<em>to (200*fraction+20).to</em>i, 500 # move the servo to position 200*fraction+20 (20-220) over the course of 500 ms
  end
end
```</p>

<p>However, often times nested callbacks can be hard to manage. Consider the following example:</p>

<p>```ruby
dyio.connect do
  pot = dyio.get<em>channel</em>as<em>potentiometer 9
  servo = dyio.get</em>channel<em>as</em>servo 10
  button = dyio.get<em>channel</em>as_button 11</p>

<p>button.on<em>every</em>change do |pushed|
    if pushed
      pot.on<em>next</em>change do |frac|
        servo.move<em>to (200*frac+20), 500
      end
      dyio.command</em>to.get<em>channel</em>values
    end
  end
end
```</p>

<p>Because of this, all of the methods in the Ruby DyIO library support the EM::Synchrony pattern, which uses Fibers to allow for pseudo-sequential code writing:</p>

<p>```ruby
dyio.connect do
  pot = dyio.get<em>channel</em>as<em>potentiometer 9
  servo = dyio.get</em>channel<em>as</em>servo 10
  button = dyio.get<em>channel</em>as_button 11</p>

<p>button.on<em>every</em>change do |pushed|
    if pushed
      val = pot.fraction
      servo.move_to (200*val+20), 500
    end
  end
end
```</p>

<p>Mixing these two style generally produces the most readable code.</p>

<h2>Advanced Topics</h2>

<h3>EventMachine Primatives</h3>

<p>All EventMachine primatives are supported.  Note, however, that in order to function properly with the EM::Synchrony functionality used inside the Ruby DyIO library, you should use the EM::Synchrony versions, and not the normal EventMachine versions.  In the event that you have an existing vanilla EventMachine method that you would like to reuse, simply wrap it with a call to EM::Synchrony#sync</p>

<h3>Custom Peripherals</h3>

<p>Any single-channel custom peripheral should inherit from the <code>Bowler::IO::Channel</code> class at minimum.  If your device provides input, you should inherit from the <code>Bowler::IO::Input</code> class instead.  Additionally, devices are expected to call the #mode= method in their constructor, so as to configure the DyIO properly before use.  The (private) method #process_data may be overridden to provide event handlers with properly formatted data.  For instance, the Bowler::IO::Peripherals::Button class defines it as such:</p>

<p><code>ruby
def process_data(data)
  val = data[:channels][@channel_number].to_i(false)
  @cached_val = if @active_high then (val != 0) else (val == 0) end
  @cached_val
end
</code></p>

<p>Arrays can be returned to pass multiple values to the event handlers (the arrays are "expanded" using <code>*arr</code> when passed to the event handler blocks).  Finally, the #get<em>channel</em>as methods are implemented by searching the Bowler::IO::Peripherals module, so any custom peripherals may be placed there for ease of use.</p>

<h3>Custom Commands</h3>

<p>Command handling is done in the Bowler::CommandHandler class.  There are two types of relevant methods to implement here: commands and parsers.</p>

<h4>Commands</h4>

<p>Now, by default unspecified commands will have their names parsed and acted on automatically (see the documentation for Bowler::CommandHandler#method<em>missing).  However, to simplify name conversion, etc, you may define your own command methods in Bowler::CommandHandler (or a subclass of it, which you can then specify as the DyIO's command</em>handler, or as a module, which you can then <code>include</code> in Bowler::CommandHandler).  For example, set<em>channel</em>value is implemented as such:</p>

<p><code>ruby
def set_channel_value(num, val, opts_hsh)
    res = nil
    val_bytes = unless (val.is_a? Array)
                val.to_a(opts_hsh[:val_size])
              else
                val
              end
    unless opts_hsh[:time].nil?
      time_bytes = opts_hsh[:time].to_a(opts_hsh[:time_size])
      self.send_command('schv', :post, num, val_bytes, time_bytes)
    else
      self.send_command('schv', :post, num, val_bytes)
    end
end
</code></p>

<h4>Parsers</h4>

<p>The Bowler::CommandHandler class is also responsible for parsing incoming packets.  Such methods
start with parse, and are called automatically based on the command name to readable name lookup hash Bowler::EVENT<em>LOOKUP</em>NAMES, or just used directly if no such entry can be found.  Such a method should take in a single paramter (the results of the #parse<em>command method), and return a hash with at least a key <code>:raw_res</code> whose value is the passed in parameter.  The following is the parse</em>channel_mode method:</p>

<p><code>ruby
def parse_channel_mode(res)
  {:raw_res =&gt; res, :mode =&gt; CHAN_MODE_NAMES[res[:data][1]], :channel =&gt; res[:data][0]}
end
</code></p>




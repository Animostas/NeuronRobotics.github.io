---
layout: info
title: "Protocol"
categories: jekyll update
---
<h1>Protocol</h1>

<div class="section">
<h2>Architecture</h2>
<p>The Bowler communication system is designed to be a distributed processing system for micro-controllers and OS based computers.
A Device's features are accessed using<b>Bowler Remote Procedure Call<b> (RPCs). These RPCs are then grouped together into <b>Bowler Namespaces<b> which serve as an interface to a specific sets of functionality(For example, IO manipulation and PID control) Each device is addressable using a IEEE standard MAC address that is unique to that device.<p>

<p>The protocol allows for the host to query a device for implemented name-spaces to allow for zero-configuration. 
</p>

<p>The  network topology is an asymmetric star, with one host (Client) to N devices (Server). The connection between these elements is called a link.
</p>

<h3>Bowler Host</h3>

<p>A Bowler Host lies at the beginning of a <b>Bowler Link</b>. It is the initiator of  Synchronous <b>Bowler Transactions</b> and the recipient of asynchronous <b>Bowler Packets</b></p>

<h3>Bowler Device</h3>

<p>A bowler device is an entity that lies at the end of a <b>Bowler Link</b> that and is involved in <b>Bowler Transactions</b>. It Implements a set of <b>Bowler_RPCs</b> divided into <b>Bowler Namespaces</b>. These RPCs allow a <b>Bowler Host</b> to manipulate and query the Device's state. State manipulations include such operations as Toggling an IO pin, or reading an ADC value.</p>

<p>A Bowler Device also sends Asynchronous <b>Bowler Packets</b> to the <b>Bowler Host</b> on the other end of the <b>Bowler Link</b></p>

<h3>Bowler Link</h3>

<h4> Introduction </h4>
A bowler link is bidirectional communications channel between a <b>Bowler Host</b> and a <b>Bowler Device</b> It is this link that <b>Bowler Packets</b> Traverse. IT is the medium in which <b>Bowler Transactions</b> occur.

<h4> Implementations </h4>
A bowler link can be implemented with any communications medium capable of transmitting data bidirectionally from one device to another. Neuron Robotics has implemented the following links.

<h4>Asynchronous Serial </h4>
The DyIO uses 115200 baud Asynchronous serial 8n1 and send the packets down the link one byte at a time starting from the first byte of the packet

<h4> Synchronous serial </h4>

<h4> TCP/IP </h4>
Packets sent over a TCP socket, In this implementation the socket server would be on the device and the socket client would be the master. An easy way to get a bowler device onto a network would be to use an existing ether-net to serial bridge like the [http://www.lantronix.com/device-networking/embedded-device-servers/xport.html XPort]

<h4> UDP/IP </h4>

<p> missing wiki info</p>

<h4> Bluetooth </h4>

<p> missing wiki info </p>

</div>

<h2>Communication</h2>

<p>Communicating with the Bowler Communication System consists of sending packets from host to device to establish a link, then packets can be sent in either direction. 
</p>

<h3>Bowler Transactions</h3>

<h4>Introduction </h4>
Communication between a <b>Bowler Host</b> and a <b>Bowler Device</b> consists of Bowler Transactions made up of <b>Bowler Packets</b> There are two types of transactions, Synchronous transactions and asynchronous transactions.

<h4>Synchronous Transactions </h4>
A Synchronous transaction is a transaction between a master and a device initiated by the master with the transmission of a Bowler Packet containing an RPC. The device, in turn, must reply with a packet containing the result of the RPC within 50ms.

For Example, When the NRSDK requests the user assigned name of a device it sends a GET Request with the RPC "INFO".  The host then has 50ms to respond with a POST response containing the name of the device.
<pre class="brush">[2011/01/21 21:42:45:414]  Debug : TX>>
	Raw Packet:	03 00 00 00 00 00 00 10 00 04 17 69 6e 66 6f 
	Revision: 	3
	MAC address: 	00:00:00:00:00:00
	Method: 	GET
	Direction: 	(0) Syncronous
	Session ID: 	0
	Data Size: 	4
	Checksum:	23
	RPC: 		info
	Data: 		69 6e 66 6f 

[2011/01/21 21:42:45:427]  Debug : RX<<
	Raw Packet:	03 74 f7 26 00 00 00 20 80 15 49 69 6e 66 6f 44 79 49 4f 20 4d 6f 64 75 6c 65 20 20 20 20 20 00 
	Revision: 	3
	MAC address: 	74:F7:26:00:00:00
	Method: 	POST
	Direction: 	(1) Syncronous
	Session ID: 	0
	Data Size: 	21
	Checksum:	73
	RPC: 		info
	Data: 		69 6e 66 6f 44 79 49 4f 20 4d 6f 64 75 6c 65 20 20 20 20 20 00 </pre>
Note, the name returned is the default name of " DyIO Module " (44 79 49 4f 20 4d 6f 64 75 6c 65 20 20 20 20 20 00)

<h4> Asynchronous Transactions </h4>
An Asynchronous transaction is a transaction the device initiates by transmitting a packet with an Asynchronous Transaction Type. The host does not respond.

Asynchronous Transactions are typically initiated when the internal state of the device has changed (IE, battery connected) or when the device has been configured by a previous Synchronous Transaction to push new data to the host(Voltage on an ADC input has changed, ADC sample, etc..).

<h3>Bowler Packets</h3>

<h4>Introduction </h4>

Communication on a <b>Bowler Link</b> consists of the exchange of <b>Bowler Packets</b>  between a <b>Bowler Host</b>  and a <b>Bowler Device</b> . Packets may be sent by either the host or device during a <b>Bowler Transaction</b>

<h4> Packet Structure </h4>

The following table defines the structure of a Bowler Packet

{| class="wikitable"
|- 
!width="50"|Size !! width="100"|Name !! width="250"|Description
|-
| 1b || Protocol Revision || The revision of the Bowler protocol to use
|-
| 6b || Target Device ID || The IEEE OUI-48 MAC address of the recipient device 
|-
| 1b || Packet Type || Metadata pertaining to how the packet will affect device state. (POST,GET,STATUS,CRITICAL)
|-
| 1bit || Direction Flag || Indicates the packet as a request or a response. 
|-
| 7bit || Namespace Collision Resolution || Used to resolve namespace collisions.
|-
| 8bit || Data Length || The length of data to come including the RPC
|-
| 1b || Header Checksum || The checksum to determine the validity of the packet 
|-
| 4b  || RPC || The [[Bowler RPC]] call identifier
|-
| 0b - 251b || Data || The rest of the data
|}

<h4> Protocoll Revision </h4>
This field contains a version number that allows a bowler device to determine if it will understand the incoming message.

<h4> Device Address </h4>
The bowler address is a globally unique address across all bowler devices. Now two devices should have the same 6 byte address. This field contains the address of the Device that is being communicated with.

One address out of all the possible addresses is treated differently. This address is the Link Local Address. It consists of all zeros (00:00:00:00:00:00) and any bowler device will respond to it.

<h4>Packet Type </h4>
The Packet type field contains information on how the RPC will affect the state of the device. They are used so that filtering and queing mechanisims can work with packets without having to have full knowlage of all the possible RPCs. There are 4 possible Method Types.

<h4>GET (0x10) </h4>
The packet is a query, It will not affect the state of the device. For example, Requesting the value of a pin.

A Device responding to a GET method would mark it's response as a POST because it affects the state of the host by providing it with new data.

<pre =class="brush">
[2011/01/21 21:57:55:993]  Debug : TX>>
	Raw Packet:	03 74 f7 26 00 00 00 10 00 05 a9 67 63 68 76 0b 
	Revision: 	3
	Device ID: 	74:F7:26:00:00:00
	Packet Type: 	GET
	Direction: 	(0) Syncronous
	Reserved: 	0
	Data Size: 	5
	Checksum: 	169
	RPC: 		gchv
	Data: 		67 63 68 76 0b 

[2011/01/21 21:57:56:136]  Debug : RX<<
	Raw Packet:	03 74 f7 26 00 00 00 20 80 07 3b 67 63 68 76 0b 00 9c 
	Revision: 	3
	Device ID: 	74:F7:26:00:00:00
	Packet Type: 	POST
	Direction: 	(1) Syncronous
	Reserved: 	0
	Data Size: 	7
	Checksum:	59
	RPC: 		gchv
	Data: 		67 63 68 76 0b 00 9c 
</pre>

<h4>POST (0x20)</h4>
The Packet Contains information intended for the device that will cause the device to change its state. For example, setting a digital output to a specific value.

A Device Responding to a POST Should mark its response packet as a STATUS packet.

<h4>STATUS (0x00)</h4>
The packet contains a Response or Status Update on a previously issued request. For Example, A POST request does not return data but affects the state of a device, A response containing ether a confirmation of success or an error would have its method set to STATUS. This method type is exclusively used for responses from the device intended for the host.


<pre class="brush:">
[2011/01/21 21:52:33:33]  Debug : TX>>
	Raw Packet:	03 74 f7 26 00 00 00 20 00 06 ba 73 63 68 76 17 01 
	Revision: 	3
	MAC address: 	74:F7:26:00:00:00
	Method: 	POST
	Direction: 	(0) Syncronous
	Session ID: 	0
	Data Size: 	6
	Checksum:	186
	RPC: 		schv
	Data: 		73 63 68 76 17 01 

[2011/01/21 21:52:33:57]  Debug : RX<<
	Raw Packet:	03 74 f7 26 00 00 00 00 80 06 1a 5f 72 64 79 02 02 
	Revision: 	3
	MAC address: 	74:F7:26:00:00:00
	Method: 	STATUS
	Direction: 	(1) Syncronous
	Session ID: 	0
	Data Size: 	6
	Checksum:	26
	RPC: 		_rdy
	Data: 		5f 72 64 79 02 02 
</pre>

<h4>CRITICAL (0x30)</h4>
A Critical high priority message that should not be interrupted or delayed if at all possible.

A Device Responding to a CRITICAL Should mark its response packet as a STATUS packet.

<h4> ASYNCHRONOUS (0x40)</h4>

An Asynchronous packet packet is sent from device to host without a request from the host. These packets are processed by the stack and passed to the user to be dealt with as they come in. An Asynchronous packet can arrive in between a synchronous packet and its response. 

<h4> Direction Flag </h4>
Packets travel along a bidirectional link between a Host and a Device. The Direction flag specifies the direction the packet is traveling. a value of 0 indicates a packet is traveling from Host to Device. Likewise, A value of 1 indicates Device to host.

<h4>Collision Resolution Number </h4>

In the event that a bowler device implements two name-spaces with identical RPCs, The device will return an error packet if this field is left zero.
To resolve this collision, the host must supply the index of the desired namespace. This index is the same as the index used in [[Bcs-core#_NMS| bcs.core._NMS]]

<h4>Data Length </h4>
The Length in bytes of the data in the payload field including the RPC.

<h4> Header Checksum </h4>
The Header Checks is a checksum that is generated from all of the previous bytes of the packet. It is used to ensure data integrity. The method of generating/validating the checksum is to add all the bytes in the header, then take the low 8 bits of the integer that represents the sum.

<h4>RPC </h4>
This contains the <b>Bowler RPC</b> and is a 4 byte code (usually ascii, but not necessarily) that is used to identify the command that the packet represents. The device will read this RPC and determine how to read the data coming with it (parameters) and how to format the packet it returns (returns).

<h4>Payload </h4>
The packet payload. Depends on the RPC. Can be empty.

<h2>Synchronous</h2>

<p>A synchronous communication is a transaction initiated by the host and responded to by the device. 
</p>

<h2>Asynchronous</h2>

<p>Once a link is established, the device can send packets to the host without the host initiating the transaction. These are <b>Asynchronous Transactions</b> consisting of one <b>Upstream Bowler Packet</b> and are used to inform the host of device state updates.
</p>

<h2>Formatting</h2>

<p>The structure of the bowler packets makes use of "Remote Procedure Calls" or RPC's. An RPC is defined within a namespace, or collection of RPC's. The RPC is a code that will define how the raw data in the data section of the packet is formatted. This formatting needs to be known by both host and device. The Host will use the list of namespaces, that the device reposts back as implementing, to determine compatibility. This allows the application to check the device for the functionality it needs. 
<h3>Bowler RPC</h3>

<h4>Bowler <b>Remote Procedure Call</b>(RPCs)</h4>

<p>In the bowler protocol a "RPC" is a 4 byte code (usually ascii, but not necessarily) that is used to identify the command that the packet represents. The device will read this RPC and determine how to read the data coming with it (parameters) and how to format the packet it returns (returns). This is similar in structure to a function call in any programming language. The function will take parameters and return data. This is where the name Remote Procedure Call comes from. RPCs are unique to their namespace. However, If two name spaces are implemented on a device, the Bowler [[Namespace collision resolution]] mechanism must be used. Invalid characters for use as an rpc include:</p> 
 "."
 ";"
 "*"
<p>These 4 bytes are arranged in  the packet with the first element of the string going first, then the second and so on. </p>

<p>All the RPC's in the bowler system must fall inside a namespace. Each namespace contains a group of RPC's that the device implements. These RPC's must be either implemented in the BCS wiki, or must be documented on a web page URL that is passed to the application from the device at runtime. All bowler devices MUST implement all of "bcs.core". For details on how the namespaces work and a list of namespaces see:</p>

<p><b>Bowler_Communications_System_Namespaces</b></p>

<h4>note</h4>
When the 4 bytes are read as an int in a little endian system, the byte order appears reversed. Be careful about your byte order when checking the RPC in a single compare.

<h3>Bowler Namespaces</h3>

<p>The idea behind the BCS Namespaces is to allow for the grouping of RPC's into services that a Bowler device implements. All valid Bowler devices must at least implement the [[bcs-core| bcs.core]] namespace.</p>


<h4>Usage</h4>
<p>The way to use the namespaces is to list on the device what namespace is implemented, what RPC's out of that namespace are implemented, what protocol revision the namespace list refers to, and optionally a URL to where to find documentation on the namespace. The syntax is to have all of that information in a string that the device sends one at a time to the application, separated by semicolons. If all RPC's are implemented in a namespace, then the '*' is used to indicate "all are implemented". Alternately, single rpc's can be named as implemented;</p>

<p> <namespace>.<which rpc's>;<revision>;<url></p>

<p>For the <b>bcs-core</b> namespace the string looks like:
 "bcs.core.*;0.3;http://neuronrobotics.com/wiki/Bcs-core;"</p>

<p>It is also valid to implement a single RPC out of a namespace. For instance, the Neuron Robotics Bootloader for the DyIO implements the '_rev' RPC out of the "neuronrobotics.dyio" namespace. That string looks like:</p>

<p> "neuronrobotics.dyio._rev;0.3;http://neuronrobotics.com/wiki/neuronrobotics-dyio;"</p>

<h4>BCS namespaces</h4>

<h5>bcs.core</h5>

<h5>bcs-io</h5>

<h5>bcs-io-setmode</h5>

<h5>bcs-pid</h5>

<h5>bcs-pid-dypid</h5>

<h4>Neuron Robotics Product namespaces</h4>

<h5>neuronrobotics-dyio</h5>

<h5>neuronrobotics-bootloader</h5>

<h4>Third Party namespaces</h4>

<b>WPI Robotics Engineering</b>

<h5>wpi-3002</h5>

<h5>wpi-aim</h5>
